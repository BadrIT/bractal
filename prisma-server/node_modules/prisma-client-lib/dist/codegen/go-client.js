"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Generator_1 = require("./Generator");
var upperCamelCase = require("uppercamelcase");
var getTypeNames_1 = require("../utils/getTypeNames");
var codeComment_1 = require("../utils/codeComment");
var goCase = function (s) {
    var cased = upperCamelCase(s);
    return cased.startsWith('Id') ? "ID" + cased.slice(2) : cased;
};
var GoGenerator = /** @class */ (function (_super) {
    __extends(GoGenerator, _super);
    function GoGenerator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.scalarMapping = {
            Int: 'int32',
            String: 'string',
            ID: 'string',
            Float: 'float32',
            Boolean: 'bool',
            DateTime: 'string',
            Json: 'map[string]interface{}',
            Long: 'int64',
        };
        _this.graphqlRenderers = {
            GraphQLUnionType: function (type) { return ""; },
            GraphQLObjectType: function (type) {
                var fieldMap = type.getFields();
                return "\n      // " + type.name + "Exec docs\n      type " + type.name + "Exec struct {\n        client    Client\n        stack []Instruction\n      }\n\n      " + Object.keys(fieldMap)
                    .filter(function (key) {
                    var field = fieldMap[key];
                    var _a = _this.extractFieldLikeType(field), isScalar = _a.isScalar, isEnum = _a.isEnum;
                    return !isScalar && !isEnum;
                })
                    .map(function (key) {
                    var field = fieldMap[key];
                    var args = field.args;
                    var _a = _this.extractFieldLikeType(field), typeFields = _a.typeFields, typeName = _a.typeName, isList = _a.isList;
                    return "\n          " + (args.length > 0 ? "\n          type " + goCase(field.name) + "ParamsExec struct {\n            " + args
                        .map(function (arg) { return goCase(arg.name) + " *" + (_this.scalarMapping[arg.type.toString()] || arg.type); }).join('\n') + "\n        }\n          " : "") + "\n          \n          // " + goCase(field.name) + " docs - executable for types\n        func (instance *" + type.name + "Exec) " + goCase(field.name) + "(" + (args.length > 0 ? "params *" + goCase(field.name) + "ParamsExec" : "") + ") *" + goCase(typeName.toString()) + "Exec" + (isList ? "Array" : "") + " {\n              var args []GraphQLArg\n              \n              " + (args.length > 0 ? "\n              if params != nil {\n                " + args.map(function (arg) { return "\n                if params." + goCase(arg.name) + " != nil {\n                  args = append(args, GraphQLArg{\n                    Name: \"" + arg.name + "\",\n                    Key: \"" + arg.name + "\",\n                    TypeName: \"" + (_this.scalarMapping[arg.type.toString()] || arg.type) + "\",\n                    Value: params." + goCase(arg.name) + ",\n                  })\n                }\n                "; }).join('\n') + "\n              }\n              " : "") + "\n\n              instance.stack = append(instance.stack, Instruction{\n                Name: \"" + field.name + "\",\n                Field: GraphQLField{\n                  Name: \"" + field.name + "\",\n                  TypeName: \"" + typeName + "\",\n                  TypeFields: " + ("[]string{" + typeFields
                        .map(function (f) { return f; })
                        .join(',') + "}") + ",\n                },\n                Operation: \"\",\n                Args: args,\n              })\n            return &" + goCase(typeName.toString()) + "Exec" + (isList ? "Array" : "") + "{\n              client: instance.client,\n              stack: instance.stack,\n            }\n          }";
                })
                    .join('\n') + "\n\n      // Exec docs\n      func (instance " + type.name + "Exec) Exec() (" + type.name + ", error) {\n        var allArgs []GraphQLArg\n        variables := make(map[string]interface{})\n        for instructionKey := range instance.stack {\n          instruction := &instance.stack[instructionKey]\n          if instance.client.Debug {\n            fmt.Println(\"Instruction Exec: \", instruction)\n          }\n          for argKey := range instruction.Args {\n            arg := &instruction.Args[argKey]\n            if instance.client.Debug {\n              fmt.Println(\"Instruction Arg Exec: \", instruction)\n            }\n            isUnique := false\n            for isUnique == false {\n              isUnique = true\n              for key, existingArg := range allArgs {\n                if existingArg.Name == arg.Name {\n                  isUnique = false\n                  arg.Name = arg.Name + \"_\" + strconv.Itoa(key)\n                  if instance.client.Debug {\n                    fmt.Println(\"Resolving Collision Arg Name: \", arg.Name)\n                  }\n                  break\n                }\n              }\n            }\n            if instance.client.Debug {\n              fmt.Println(\"Arg Name: \", arg.Name)\n            }\n            allArgs = append(allArgs, *arg)\n            variables[arg.Name] = arg.Value\n          }\n        }\n        query := instance.client.ProcessInstructions(instance.stack)\n        if instance.client.Debug {\n          fmt.Println(\"Query Exec:\", query)\n          fmt.Println(\"Variables Exec:\", variables)\n        }\n        data, err := instance.client.GraphQL(query, variables)\n        if instance.client.Debug {\n          fmt.Println(\"Data Exec:\", data)\n          fmt.Println(\"Error Exec:\", err)\n        }\n\n        var genericData interface{} // This can handle both map[string]interface{} and []interface[]\n\n        // Is unpacking needed\n        dataType := reflect.TypeOf(data)\n        if !isArray(dataType) {\n          unpackedData := data\n          for _, instruction := range instance.stack {\n            if instance.client.Debug {\n              fmt.Println(\"Original Unpacked Data Step Exec:\", unpackedData)\n            }\n            if isArray(unpackedData[instruction.Name]) {\n              genericData = (unpackedData[instruction.Name]).([]interface{})\n              break\n            } else {\n              unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})\n            }\n            if instance.client.Debug {\n              fmt.Println(\"Partially Unpacked Data Step Exec:\", unpackedData)\n            }\n            if instance.client.Debug {\n              fmt.Println(\"Unpacked Data Step Instruction Exec:\", instruction.Name)\n              fmt.Println(\"Unpacked Data Step Exec:\", unpackedData)\n              fmt.Println(\"Unpacked Data Step Type Exec:\", reflect.TypeOf(unpackedData))\n            }\n            genericData = unpackedData\n          }\n        }\n        if instance.client.Debug {\n          fmt.Println(\"Data Unpacked Exec:\", genericData)\n        }\n\n        var decodedData " + type.name + "\n        mapstructure.Decode(genericData, &decodedData)\n        if instance.client.Debug {\n          fmt.Println(\"Data Exec Decoded:\", decodedData)\n        }\n        return decodedData, err\n      }\n      \n      // " + type.name + "ExecArray docs\n      type " + type.name + "ExecArray struct {\n        client    Client\n        stack []Instruction\n      }\n\n      // Exec docs\n      func (instance " + type.name + "ExecArray) Exec() ([]" + type.name + ", error) {\n        query := instance.client.ProcessInstructions(instance.stack)\n        variables := make(map[string]interface{})\n        for _, instruction := range instance.stack {\n          if instance.client.Debug {\n            fmt.Println(\"Instruction Exec: \", instruction)\n          }\n          for _, arg := range instruction.Args {\n            if instance.client.Debug {\n              fmt.Println(\"Instruction Arg Exec: \", instruction)\n            }\n            variables[arg.Name] = arg.Value\n          }\n        }\n        if instance.client.Debug {\n          fmt.Println(\"Query Exec:\", query)\n          fmt.Println(\"Variables Exec:\", variables)\n        }\n        data, err := instance.client.GraphQL(query, variables)\n        if instance.client.Debug {\n          fmt.Println(\"Data Exec:\", data)\n          fmt.Println(\"Error Exec:\", err)\n        }\n\n        var genericData interface{} // This can handle both map[string]interface{} and []interface[]\n\n        // Is unpacking needed\n        dataType := reflect.TypeOf(data)\n        if !isArray(dataType) {\n          unpackedData := data\n          for _, instruction := range instance.stack {\n            if instance.client.Debug {\n              fmt.Println(\"Original Unpacked Data Step Exec:\", unpackedData)\n            }\n            if isArray(unpackedData[instruction.Name]) {\n              genericData = (unpackedData[instruction.Name]).([]interface{})\n              break\n            } else {\n              unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})\n            }\n            if instance.client.Debug {\n              fmt.Println(\"Partially Unpacked Data Step Exec:\", unpackedData)\n            }\n            if instance.client.Debug {\n              fmt.Println(\"Unpacked Data Step Instruction Exec:\", instruction.Name)\n              fmt.Println(\"Unpacked Data Step Exec:\", unpackedData)\n              fmt.Println(\"Unpacked Data Step Type Exec:\", reflect.TypeOf(unpackedData))\n            }\n            genericData = unpackedData\n          }\n        }\n        if instance.client.Debug {\n          fmt.Println(\"Data Unpacked Exec:\", genericData)\n        }\n\n        var decodedData []" + type.name + "\n        mapstructure.Decode(genericData, &decodedData)\n        if instance.client.Debug {\n          fmt.Println(\"Data Exec Decoded:\", decodedData)\n        }\n        return decodedData, err\n      }\n\n      // " + type.name + " docs - generated with types\n      type " + type.name + " struct {\n          " + Object.keys(fieldMap)
                    .filter(function (key) {
                    var field = fieldMap[key];
                    var isScalar = _this.extractFieldLikeType(field).isScalar;
                    return isScalar;
                })
                    .map(function (key) {
                    var field = fieldMap[key];
                    var _a = _this.extractFieldLikeType(field), typeName = _a.typeName, isNonNull = _a.isNonNull, isScalar = _a.isScalar;
                    return goCase(field.name) + " " + (isScalar ? "" : "*") + (_this
                        .scalarMapping[typeName] || typeName) + " `json:\"" + field.name + (isNonNull ? "" : ",omitempty") + "\"`";
                })
                    .join('\n') + "\n            }\n        ";
            },
            GraphQLInterfaceType: function (type) {
                var fieldMap = type.getFields();
                return "\n      // " + goCase(type.name) + "Exec docs\n      type " + goCase(type.name) + "Exec struct {\n        client    Client\n        stack []Instruction\n      }\n\n      // " + goCase(type.name) + " docs - generated with types in GraphQLInterfaceType\n      type " + goCase(type.name) + " interface {\n        " + Object.keys(fieldMap).map(function (key) {
                    var field = fieldMap[key];
                    var typeName = _this.extractFieldLikeType(field).typeName;
                    return goCase(field.name) + "() " + (_this.scalarMapping[typeName] ||
                        typeName);
                }) + "\n      }";
            },
            GraphQLInputObjectType: function (type) {
                var fieldMap = type.getFields();
                return "// " + type.name + " input struct docs\n      type " + type.name + " struct {\n          " + Object.keys(fieldMap)
                    .map(function (key) {
                    var field = fieldMap[key];
                    var typeName = _this.extractFieldLikeType(field).typeName;
                    return goCase(field.name) + " *" + (_this.scalarMapping[typeName] ||
                        typeName) + " `json:\"" + field.name + ",omitempty\"`";
                })
                    .join('\n') + "\n            }\n        ";
            },
            GraphQLScalarType: function (type) { return ""; },
            GraphQLIDType: function (type) { return ""; },
            GraphQLEnumType: function (type) {
                var enumValues = type.getValues();
                return "\n            // " + type.name + " docs\n            type " + type.name + " string\n            const (\n                " + enumValues
                    .map(function (v) {
                    return "\n                      // " + goCase(v.name) + type.name + " docs\n                      " + goCase(v.name) + type.name + " " + type.name + " = \"" + v.name + "\"";
                })
                    .join('\n') + "\n            )\n        ";
            },
        };
        _this.graphqlTypeRenderersForQuery = {
            GraphQLScalarType: function (type) {
                return "";
            },
            GraphQLObjectType: function (type) {
                var typeFields = type.getFields();
                return "" + Object.keys(typeFields)
                    .map(function (key) {
                    var field = typeFields[key];
                    var isScalar = _this.extractFieldLikeType(field).isScalar;
                    return isScalar ? "" + field.name : "";
                })
                    .join('\n');
            },
            GraphQLInterfaceType: function (type) {
                return "";
            },
            GraphQLUnionType: function (type) {
                return "";
            },
            GraphQLEnumType: function (type) {
                return "";
            },
            GraphQLInputObjectType: function (type) {
                var typeFields = type.getFields();
                return "" + Object.keys(typeFields)
                    .map(function (key) {
                    var field = typeFields[key];
                    return "" + field.name;
                })
                    .join('\n');
            },
        };
        return _this;
    }
    GoGenerator.prototype.extractFieldLikeType = function (field) {
        var _this = this;
        var deepTypeName = this.getDeepType(field.type);
        var deepType = this.schema.getType(deepTypeName);
        var isScalar = deepType.constructor.name === 'GraphQLScalarType';
        var isEnum = deepType.constructor.name === 'GraphQLEnumType';
        var isInput = deepType.constructor.name === 'GraphQLInputObjectType';
        var isList = field.type.toString().indexOf('[') === 0 &&
            field.type.toString().indexOf(']') > -1;
        var isNonNull = field.type.toString().indexOf('!') > -1 && field.type.toString().indexOf('!]') === -1;
        var fieldMap = null;
        if (deepType.constructor.name === 'GraphQLObjectType') {
            fieldMap = deepType.getFields();
        }
        if (deepType.constructor.name === 'GraphQLInputObjectType') {
            fieldMap = deepType.getFields();
        }
        var fields = Boolean(fieldMap)
            ? Object.keys(fieldMap)
                .filter(function (key) {
                var field = fieldMap[key];
                return (_this.getDeepType(field.type).constructor.name ===
                    'GraphQLScalarType');
            })
                .map(function (key) { return "\"" + fieldMap[key].name + "\""; })
            : [];
        return {
            name: field.name,
            typeName: deepTypeName.toString(),
            type: deepType,
            typeFields: fields,
            args: field.args,
            isScalar: isScalar,
            isEnum: isEnum,
            isList: isList,
            isNonNull: isNonNull,
            isInput: isInput,
        };
    };
    GoGenerator.prototype.getDeepType = function (type) {
        if (type.ofType) {
            return this.getDeepType(type.ofType);
        }
        return type;
    };
    GoGenerator.prototype.printOperation = function (fields, operation, options) {
        var _this = this;
        return Object.keys(fields)
            .map(function (key) {
            var field = fields[key];
            var args = field.args;
            var _a = _this.extractFieldLikeType(field), typeFields = _a.typeFields, typeName = _a.typeName, isList = _a.isList;
            var whereArgs = args.filter(function (arg) { return arg.name === 'where'; });
            var whereArg = null;
            if (whereArgs.length > 0) {
                whereArg = whereArgs[0];
            }
            return "\n\n          " + (operation === 'query' && !isList && whereArg
                ? "\n              // Exists\n\n              // " + goCase(field.name) + " exists docs\n              func (exists *Exists) " + goCase(field.name) + "(params *" + goCase(_this.getDeepType(whereArg.type).toString()) + ") bool {\n                client := Client{\n                  Endpoint: (map[bool]string{true: exists.Endpoint, false: " + _this.printEndpoint(options) + "})[exists.Endpoint != \"\"],\n                  Debug: exists.Debug,\n                }\n                data, err := client." + goCase(field.name) + "(\n                  " + (args.length === 1
                    ? "params,"
                    : "&" + goCase(field.name) + "Params{\n                    Where: params,\n                  },") + "\n                ).Exec()\n                if err != nil {\n                  if client.Debug {\n                    fmt.Println(\"Error Exists\", err)\n                  }\n                  return false\n                }\n                if isZeroOfUnderlyingType(data) {\n                  return false\n                }\n                return true\n              }\n          "
                : "") + " \n\n          // " + goCase(field.name) + "Params docs\n          type " + goCase(field.name) + "Params struct {\n            " + args
                .map(function (arg) {
                var _a = _this.extractFieldLikeType(arg), typeName = _a.typeName, isNonNull = _a.isNonNull;
                return goCase(arg.name) + " *" + (_this.scalarMapping[typeName] ||
                    typeName) + " `json:\"" + arg.name + (isNonNull ? "" : ",omitempty") + "\"`";
            })
                .join('\n') + "\n          }\n          \n          // " + goCase(field.name) + " docs - generated while printing operation - " + operation + "\n          func (client Client) " + goCase(field.name) + " (" + (args.length === 1
                ? "params *" + _this.getDeepType(args[0].type)
                : "params *" + goCase(field.name) + "Params") + ") *" + goCase(typeName) + "Exec" + (isList ? "Array" : "") + " {\n\n          stack := make([]Instruction, 0)\n          var args []GraphQLArg\n          " + args
                .map(function (arg) {
                return "if params != nil " + (args.length === 1 ? "" : "&& params." + goCase(arg.name) + " != nil") + " {\n                args = append(args, GraphQLArg{\n                  Name: \"" + arg.name + "\",\n                  Key: \"" + arg.name + "\",\n                  TypeName: \"" + arg.type + "\",\n                  Value: *params" + (args.length === 1 ? "" : "." + goCase(arg.name)) + ",\n                })\n              }";
            })
                .join('\n') + "\n          \n          stack = append(stack, Instruction{\n            Name: \"" + field.name + "\",\n            Field: GraphQLField{\n              Name: \"" + field.name + "\",\n              TypeName: \"" + typeName + "\",\n              TypeFields: " + ("[]string{" + typeFields.map(function (f) { return f; }).join(',') + "}") + ",\n            },\n            Operation: \"" + operation + "\",\n            Args: args,\n          })\n\n          return &" + goCase(typeName) + "Exec" + (isList ? "Array" : "") + "{\n            client: client,\n            stack: stack,\n          }\n        }";
        })
            .join('\n');
    };
    GoGenerator.prototype.printEndpoint = function (options) {
        if (options.endpoint.startsWith('process.env')) {
            // Find a better way to generate Go env construct
            var envVariable = ("" + options.endpoint
                .replace('process.env[', '')
                .replace(']', ''))
                .replace("'", '')
                .replace("'", '');
            return "os.Getenv(\"" + envVariable + "\")";
        }
        else {
            return "\"" + options.endpoint.replace("'", '').replace("'", '') + "\"";
        }
    };
    GoGenerator.prototype.renderLib = function (options) {
        return "\n" + codeComment_1.codeComment + "\npackage prisma\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"reflect\"\n)\n\n// GraphQLField docs\ntype GraphQLField struct {\n  Name string\n  TypeName string\n  TypeFields []string\n}\n\n// GraphQLArg docs\ntype GraphQLArg struct {\n  Name string\n  Key string\n  TypeName string\n  Value interface{}\n}\n\n// Instruction docs\ntype Instruction struct {\n  Name string\n  Field GraphQLField\n  Operation string\n\tArgs []GraphQLArg\n}\n\nfunc isZeroOfUnderlyingType(x interface{}) bool {\n\treturn reflect.DeepEqual(x, reflect.Zero(reflect.TypeOf(x)).Interface())\n}\n\nfunc isArray(i interface{}) bool {\n  v := reflect.ValueOf(i)\n  switch v.Kind() {\n  case reflect.Array:\n    return true\n  case reflect.Slice:\n    return true\n  default:\n    return false\n  }\n}\n\ntype PrismaOptions struct {\n\tEndpoint string\n\tDebug    bool\n}\n\nfunc New(options *PrismaOptions) Client {\n  if options == nil {\n    return Client{}\n  }\n\treturn Client{\n\t\tEndpoint: options.Endpoint,\n\t\tDebug:    options.Debug,\n\t\tExists: Exists{\n\t\t\tEndpoint: options.Endpoint,\n\t\t\tDebug:    options.Debug,\n\t\t},\n\t}\n}\n\ntype Client struct {\n  Endpoint string\n  Debug bool\n  Exists Exists\n}\n\n// Exists docs\ntype Exists struct {\n\tEndpoint string\n\tDebug    bool\n}\n\n// ProcessInstructions docs\nfunc (client *Client) ProcessInstructions(stack []Instruction) string {\n\tquery := make(map[string]interface{})\n\targsByInstruction := make(map[string][]GraphQLArg)\n\tvar allArgs []GraphQLArg\n\tfirstInstruction := stack[0]\n\tfor i := len(stack) - 1; i >= 0; i-- {\n\t\tinstruction := stack[i]\n\t\tif client.Debug {\n\t\t\tfmt.Println(\"Instruction: \", instruction)\n\t\t}\n\t\tif len(query) == 0 {\n\t\t\tquery[instruction.Name] = instruction.Field.TypeFields\n      argsByInstruction[instruction.Name] = instruction.Args\n      for _, arg := range instruction.Args {\n\t\t\t\tallArgs = append(allArgs, arg)\n\t\t\t}\n\t\t} else {\n\t\t\tpreviousInstruction := stack[i+1]\n\t\t\tquery[instruction.Name] = map[string]interface{}{\n\t\t\t\tpreviousInstruction.Name: query[previousInstruction.Name],\n\t\t\t}\n      argsByInstruction[instruction.Name] = instruction.Args\n      for _, arg := range instruction.Args {\n\t\t\t\tallArgs = append(allArgs, arg)\n\t\t\t}\n\t\t\tdelete(query, previousInstruction.Name)\n\t\t}\n\t}\n\n\tif client.Debug {\n\t\tfmt.Println(\"Final Query:\", query)\n\t\tfmt.Println(\"Final Args By Instruction:\", argsByInstruction)\n\t\tfmt.Println(\"Final All Args:\", allArgs)\n\t}\n\n\t// TODO: Make this recursive - current depth = 3\n\tqueryTemplateString := `\n  {{ $.operation }} {{ $.operationName }} \n  \t{{- if eq (len $.allArgs) 0 }} {{ else }} ( {{ end }}\n    \t{{- range $_, $arg := $.allArgs }}\n\t\t\t${{ $arg.Name }}: {{ $arg.TypeName }}, \n\t\t{{- end }}\n\t{{- if eq (len $.allArgs) 0 }} {{ else }} ) {{ end }}\n    {\n    {{- range $k, $v := $.query }}\n    {{- if isArray $v }}\n\t  {{- $k }}\n\t  {{- range $argKey, $argValue := $.argsByInstruction }}\n\t  {{- if eq $argKey $k }}\n\t  \t{{- if eq (len $argValue) 0 }} {{ else }} ( {{ end }}\n\t\t\t\t{{- range $k, $arg := $argValue}}\n\t\t\t\t\t{{ $arg.Key }}: ${{ $arg.Name }},\n\t\t\t\t{{- end }}\n\t\t{{- if eq (len $argValue) 0 }} {{ else }} ) {{ end }}\n\t\t\t{{- end }}\n\t\t{{- end }}\n\t  {\n        {{- range $k1, $v1 := $v }}\n          {{ $v1 }}\n        {{end}}\n      }\n    {{- else }}\n\t  {{ $k }} \n\t  {{- range $argKey, $argValue := $.argsByInstruction }}\n\t  \t{{- if eq $argKey $k }}\n\t  \t\t{{- if eq (len $argValue) 0 }} {{ else }} ( {{ end }}\n            {{- range $k, $arg := $argValue}}\n              {{ $arg.Key }}: ${{ $arg.Name }},\n            {{- end }}\n\t\t\t{{- if eq (len $argValue) 0 }} {{ else }} ) {{ end }}\n          {{- end }}\n        {{- end }}\n\t\t{\n        {{- range $k, $v := $v }}\n        {{- if isArray $v }}\n\t\t  {{ $k }} \n\t\t  {{- range $argKey, $argValue := $.argsByInstruction }}\n\t\t  {{- if eq $argKey $k }}\n\t\t\t{{- if eq (len $argValue) 0 }} {{ else }} ( {{ end }}\n                {{- range $k, $arg := $argValue}}\n                  {{ $arg.Key }}: ${{ $arg.Name }},\n                {{- end }}\n\t\t\t\t{{- if eq (len $argValue) 0 }} {{ else }} ) {{ end }} \n              {{- end }}\n            {{- end }}\n\t\t\t{ \n            {{- range $k1, $v1 := $v }}\n              {{ $v1 }}\n            {{end}}\n          }\n        {{- else }}\n\t\t  {{ $k }} \n\t\t  {{- range $argKey, $argValue := $.argsByInstruction }}\n\t\t  {{- if eq $argKey $k }}\n\t\t  \t{{- if eq (len $argValue) 0 }} {{ else }} ( {{ end }}\n                {{- range $k, $arg := $argValue}}\n                  {{ $arg.Key }}: ${{ $arg.Name }},\n                {{- end }}\n\t\t\t\t{{- if eq (len $argValue) 0 }} {{ else }} ) {{ end }} \n              {{- end }}\n            {{- end }}\n\t\t\t{\n            {{- range $k, $v := $v }}\n              {{- if isArray $v }}\n                {{ $k }} { \n                  {{- range $k1, $v1 := $v }}\n                    {{ $v1 }}\n                  {{end}}\n                }\n              {{- else }}\n\t\t\t\t{{ $k }} \n\t\t\t\t{{- range $argKey, $argValue := $.argsByInstruction }}\n\t\t\t\t{{- if eq $argKey $k }}\n\t\t\t\t\t{{- if eq (len $argValue) 0 }} {{ else }} ( {{ end }}\n                      {{- range $k, $arg := $argValue}}\n                        {{ $arg.Key }}: ${{ $arg.Name }},\n                      {{- end }}\n\t\t\t\t\t  {{- if eq (len $argValue) 0 }} {{ else }} ) {{ end }} \n                    {{- end }}\n                  {{- end }}\n\t\t\t\t  {\n                  id\n                }\n              {{- end }}\n              {{- end }}\n          }\n        {{- end }}\n        {{- end }}\n      }\n    {{- end }}\n    {{- end }}\n    }\n  `\n\n\ttemplateFunctions := template.FuncMap{\n\t\t\"isArray\": isArray,\n\t}\n\n\tqueryTemplate, err := template.New(\"query\").Funcs(templateFunctions).Parse(queryTemplateString)\n\tvar queryBytes bytes.Buffer\n\tvar data = make(map[string]interface{})\n\tdata = map[string]interface{}{\n\t\t\"query\":             query,\n\t\t\"argsByInstruction\": argsByInstruction,\n\t\t\"allArgs\":           allArgs,\n\t\t\"operation\":         firstInstruction.Operation,\n\t\t\"operationName\":     firstInstruction.Name,\n\t}\n\tqueryTemplate.Execute(&queryBytes, data)\n\n\tif client.Debug {\n\t\tfmt.Println(\"Query String: \", queryBytes.String())\n\t}\n\tif err == nil {\n\t\treturn queryBytes.String()\n\t}\n\treturn \"Failed to generate query\"\n}\n    ";
    };
    GoGenerator.prototype.render = function (options) {
        var _this = this;
        var typeNames = getTypeNames_1.getTypeNames(this.schema);
        var typeMap = this.schema.getTypeMap();
        var queryType = this.schema.getQueryType();
        var queryFields = queryType.getFields();
        var mutationType = this.schema.getMutationType();
        var mutationFields = mutationType.getFields();
        return "\n// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.\npackage prisma\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\n\t\"github.com/machinebox/graphql\"\n\t\"github.com/mitchellh/mapstructure\"\n)\n\n// ID docs\ntype ID struct{}\n\n// Queries\n" + this.printOperation(queryFields, 'query', options) + "\n\n// Mutations\n" + this.printOperation(mutationFields, 'mutation', options) + "\n\n// Types\n\n" + typeNames
            .map(function (key) {
            var type = typeMap[key];
            return _this.graphqlRenderers[type.constructor.name]
                ? _this.graphqlRenderers[type.constructor.name](type)
                : "// No GraphQL Renderer for Type " + type.name + " of type " + type.constructor.name;
        })
            .join('\n') + "\n\n// GraphQL Send a GraphQL operation request\nfunc (client Client) GraphQL(query string, variables map[string]interface{}) (map[string]interface{}, error) {\n\t// TODO: Add auth support\n\n\treq := graphql.NewRequest(query)\n\tgqlClient := graphql.NewClient(\n      (map[bool]string{true: client.Endpoint, false: " + this.printEndpoint(options) + "})[client.Endpoint != \"\"],\n    )\n\n\tfor key, value := range variables {\n    req.Var(key, value)\n\t}\n\n\tctx := context.Background()\n\n\t// var respData ResponseStruct\n\tvar respData map[string]interface{}\n\tif err := gqlClient.Run(ctx, req, &respData); err != nil {\n    if client.Debug {\n      fmt.Println(\"GraphQL Response:\", respData)\n    }\n\t\treturn nil, err\n\t}\n\treturn respData, nil\n}\n        ";
    };
    return GoGenerator;
}(Generator_1.Generator));
exports.GoGenerator = GoGenerator;
//# sourceMappingURL=go-client.js.map